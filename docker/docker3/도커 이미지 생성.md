## 도커 이미지 생성 순서

Dockerfile() -> docker client -> docker server -> image created

Dockerfile 도커 이미지를 만들기 위한 설정 파일이다. 즉 도커 파일에 종속성이나 설정(코드)등이 담긴다.

docker client -> 도커 파일 내용인 전다되어 서버로 담긴다.

docker server -> 도커 파일로 만들어진 내용과 어떤 액션을 해야하는지 도커 클라이언트에서 전달받은대로 내용을 처리한다.


## Dockerfile 
Dockerfile

-   도커 파일은 도커 이미지를 마들기 위한 설정 파일이며, 컨테이너가 어떻게 행동하는지 지정해두는것
    

도커 파일 만드는 순서(도커 이미지가 필요한 것이 무엇인지 생각하기)

1.  베이스 이미지 명시
    
2.  추가적으로 필요한 파일을 다운 받기 위한 몇가지 명령어를 명시해준다.
    
3.  컨테이너 시작시 실행될 명령어를 명시해준다.
    

베이스 이미지란? OS라고 생각하면된다 => 베이스 이미지 즉 OS를 만들고 그리고 필요한 이미지(레이어)들을 위에 쌓는다 = 운영체제 위에 필요한 어플리케이션 더하는것과 같음

1.  도커파일이 생성될 폴더하나 만들기
    
2.  Dockerfile이라는 파일 생성
    
    -   FROM: 이미지 생성시 기반이 되는 이미지 레이어
        
        FROM <이미지>:<tag(버전명)>
        
    -   RUN
        
        RUN: baseImg 위에 쌓아나갈 레이어 다운로드
        
    -   CMD
        
        컨테이너를 실행시키기 위해 쓰이는 명령어로 쉘스크립트 또는 파일이 실행된다. 도커파일에서는 여러번의 RUN을 할수있지만 한번의 CMD밖에 못한다.

## Dockerfile 작성후 이미지로 생성(도커 클라이언트에 전달)

Dockerfile 작성후 이미지로 생성하기

도커 파일에 입력된 내용은 도커 클라이언트로 전달되어야 하고 그리고 서버로 전달되어 내용을 처리해야한다.

docker build . (또는 ./ 둘다 현재 디렉토리에서 Dockerfile을 찾아 도커 클라이언트에 전달하겠다는 명령어)

이미지로 임시 컨테이너(빈깡통)만들고 거기안에 새로운 명령어와 필요한 스냅샷을 추가한다. -> 임시 컨테이너를 이용하여 우리가 필요한 정보만 담긴 이미지를 만든다.

## Dockerfile을 태그 붙여 클라이언트에 전달하기(이미지로 만들기)
docker run -it <이미지명> => 해당 이미지를 실행시키기 위해서는 docker run을 해줘야 하고 결과 값을 보기 위해서 -it를 넣어줌

도커 이미지에 이름주는 방법: docker build -t lionjy06/projectName:latest

도커 이름 짓는 방식에는 컨벤션이 있다 -t 옵션을 이용하여 이름을 지정할수 있으나 컨벤션은 다음과 같다 <나의 도커 아이디>/저장소(프로젝트 명): 버전

docker build -t lionjy06/testproject:latest ./

docker run -it lionjy06/testproject

## 포트매핑

-p 옵션 => 우리가 만든 컨테이너가 외부와 통신이 가능하려면 포트를 연결해주어야 한다.

포트매핑: 외부포트와 내부포트를 연결해주어야 외부에서 내부로 접근이 가능해진다.

docker run -p <외부포트>:<내부포트> <이미지이름>

## WORKDIR
workdir은 dockefile로 이미지를 만들때 이미지 스냅샷과 설정파일이 위치하는곳을 정해줄수있다. workdir이 없다면 첫째, 루트 디렉토리가 굉장히 지저분해진다. 루트 디렉토리에는 bin, exc등 여러 파일 디렉토리가 존재하는데 그곳에 어플리케이션 파일까지 공존하면 너무 지저분해진다. 두번째, 만약 어플리케이션 디렉토리와 루트에 있는 파일디렉토리 이름이 같다면 기존의 루트디렉토리에 존재하는 파일 디렉토리가 사라지고 그 이름을 어플리케이션 디렉토리가 가져다 써버린다. 

## 소스코드 변경때마다 빌드를 해야하는 비효율성
문제가 생기거나 필요에 의해 소스를 변경시키면 이미지 생성 부터 다시 빌드해야한다. -> 작은것만 바꾸었는데 전체를 다시 빌드 해줘야하는것은 너무 시간낭비;;

= 소스코드 한줄만 바뀌어도 docker stop <컨테이너명> -> docker build -t <이름> ./ -> docker run -d -p <외부포트>:<내부포트> <이미지명>

-> 소스코드 하나만 바뀌어도 위와같은 과정이 전부 다 일어나게 되는데 너무 비효율적이다.

그렇다면 어떻게 하면 개선할수있을까?

```
Dockerfile

FROM node:16

WORKDIR /practice_backend/

COPY package.json ./

RUN npm install

COPY ./ ./

CMD ["node","server.js"]

```
왜 package.json을 먼저 copy하고 npm install 하고 소스코드를 복사해 오는것이 효율적일까?? -> package.json만 받아놓으면 소스코드만 변경이있고 종속성에 변경이 없다면 불필요한 종속성을 다운받지 않고 이미 캐싱되어있는 자료로 빠르게 빌드하고 소스코드만 복제해온다.


## volume
volume은 도커 컨테이너와 로컬 소스코드를 매핑시켜 소스코드의 변경이 있을시 도커가 이미지 재빌드없이 바로 소스코드를 적용시키는 것이다.

-   종속성에 변경이 있을시에는 재빌드해줘야하는것이 맞음.
    

docker run -p <외부포트>:<내부포트> -v <workdir경로>/node_modules -v $(pwd) :<workdir> <이미지명>

:를 기준으로 왼쪽(pwd)는 로컬(참조하는 소스가 있는 로컬) <workdir 경로>는 도커. 두개를 매핑시켜 서로 바라보게 할수있다.

node_modules는 앞에 참조하는 부분이 없기때문에 아무것도 참조하지않는다. 즉 node_modules는 가져오지않는다.

docker run -d -p 8080:8080 -v /practice_backend/node_modules -v $(pwd):/practice_backend lionjy06/nodejs

소스코드가 변경되면 일단 한번 컨테이너를 stop하고 위처럼 -v옵션을 주어 매핑을 연결해주면 이미지 빌드없이 바로 소스코드 변경이 적용된다.

=> 개인적으론 이것도 별로다, 애초에 docker container를 스톱해야 되는것 자체가 맘에안듬... 로컬에서 소스코드 변경후 저장 누르면 바로 적용됫으면 좋겠다.

